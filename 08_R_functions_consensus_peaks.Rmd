---
title: "Creating Consensus Peaks / functions in R"
author: "JR"
date: "11/29/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```



First we are going to go over a "function" in R. This is a really nice feature of 
defining a function for R that you may run frequently. For example we have over 
1,000 peak files we have to import into R using the function below. 

We need a few minimum aspects in defining a function:
-note we use #' markdown for a function.

@description: describes the function
@param is a paramater that the function needs. 

Essentially R has many built in functions such as mutate that needs parameters etc.


Lets take a look.
```{r}

#' import peak .bed files as a list
#' 
#' @description 
#' this function will take consensus peak files and name them by the DNA binding protein and return a list
#' 
#' @param consensus_file_path the path to consensus peak files

```

Hopefully it is pretty self-explanatory that the function will only need one 
parameter -- the file path to the peak files generated by nextflow (.broadPeak)


This is the file path for the function parameter:

/Shares/rinn_class/data/CLASS_2021/CLASS_2021/data/test_work/all_peak_files

So now we will see the function get set up to work. The goal is to read in all
the files using this function. 

We will start by naming the function "import_peaks" 
We next call the function and give the parameter -- this is fed into "consensus peaks"

Now we are going to make some objects:

*peak_files: this is just going to be a list of the peak file names
this used the R function "list.files" -- take a look:
?list.files

*file_names: here we use the Tidyverse R function string extract (str_extract)
?str_extract (need tidyverse library loaded)
The arguments are:

string: the input vector of coerciable data (e.g. character string) -- peak_files
pattern: the pattern to look for across the input vector. this is using regular
expression (regex). You don't need to know this much regex, but if you are ever 
curious you can use the online regex calculator :)

https://regexr.com/

if you paste in the two regex commands below it will tell you what they are looking for.

*tf_name: here we are going to have the funciton grab the name of the DBP or TF 
that is associated with the file being read in peak_files. 

Overall, we are grabbing all the file names, using regex to parse the complex file
name into a simple file name attached to the DBP.


```{r}
import_peaks <- function(consensus_file_path = "/Shares/rinn_class/data/CLASS_2021/CLASS_2021/data/test_work/all_peak_files") {
  peak_files <- list.files(consensus_file_path, full.names = T)
  file_names <- str_extract(peak_files, "[\\w-]+\\.bed")
  tf_name <- str_extract(file_names, "^[^_]+(?=_)")
  
## Now we are going to use the data structures above in a forloop. 

  peak_list <- c()
## We will make an empyt object called peak_lists using <- () 
  for(i in 1:length(peak_files)) {
## next we set up the for loop to populate peak_list, for i through (:) the legnth of (peak_files).
    ## length is a base R function (? length)
## This starts the for loop to run through each of the file names in peak_files
    peaks <- rtracklayer::import(peak_files[i])
## here we are going to import the "ranges" or locations of the peaks in each file
## this is using the GRanges R package with 
## the 'rtracklayer::import' is using '::' to say use the package rtracklayer import
## function and not the base R import funciton etc. Many packages use functions
## with the same names, so you want to call them directly with ::
## We will discuss Iranges and Granges soon, but for now the importance of this
## is to index the chromosome and coordinates of each peak for each DBP. rtracklayer
## knows how to do this.
    
    peak_list <- c(peak_list, peaks)
## Here we are simply concatinating what is in 'peak_list' with what was put into 
## 'peaks' above
    
    names(peak_list)[length(peak_list)] <- tf_name[i]
    
## ?names
## ?length
## here we see the base R funciton "names" it does exactly what it sounds like
## it either sets or get's the names in an onject (e.g. peak_list)
## so we are running names on the "peak_list" object and then indexing into "peak_list"
## using [ ] that we have seen before.
## whats new here is running a function (lenght) in the indexing!
## length will set the length of names to be the length of peak list -- remember
## 'peak_list' is getting populated each time in the for loop so we need to have
## names add until there are no more files coming into 'peak_list' from the for loop.

## finally we made 'tf_name' above which is connected to each file in the loop (i:legnth peak_files)
## we are now going to plug this into the name of the file currently in 'peak_list'
    
  }
  return(peak_list)
}

## simply closing out the function and has the funciton return the peak_list object
## a function will always want a return command at the end.
```






Now we have our peak_files in an object that knows where the peaks are on
each chromosome. Next we want to merge the peaks called in each replicate to 
"consensus peaks" that are consistent in all replicates. Thus we will compress
our peak_list into a final set of peaks that are reliable across biological replicates.


We start with a similar funciton set up:


```{r}
#' intersect replicates into a "consensus peak list" 
#' 
#' @description 
#' this function will take the intersect and union of peak widths across replicates for a given DNA binding protein. the function that will take a list of granges objects and return 
# one granges object with merged peaks that are in all replicates
#' 
#' @param 
#'  the path to consensus peak files
#' # We're going to iterate over all the files to make it work. 

```


Now we are going to put the function to work and give it the same file path
paramater as above. Then the function will carry out all the commands between { }
```{r}
create_consensus_peaks <- function(broadpeakfilepath = "/Shares/rinn_class/data/CLASS_2021/CLASS_2021/data/test_work/all_peak_files") {
  
  
  fl <- list.files(broadpeakfilepath, 
                   full.names=TRUE)
  fl <- fl[grep("broadPeak", fl)]

## Here we are reading in files first again and putting them in the object "create_consensus_peaks"
## We are using grep to just grab broadPeak files. This is because the macs folder has many different
## versions of peak files. It is just useful to be sure it grabs the right file type.
## In our case the folder all_peak_files is only broadPeak files so a bit redundant....for safety.
  
  tf_name <- sapply(fl, function(x){
    y <-  unlist(strsplit(x, "/"))[[11]]
    unlist(strsplit(y, "_"))[[1]]
  })
## So many new functions
## ?sapply
## ?Unlist
## ?strsplit

## TODO EXPLAIN
## The first command sapply needs a parameter of what to work on (fl or list of file names)
## then sapply wants to perform a funciton -- here we set the function to carry out the content in { }
## Here these commands are being executed in the function(x) and later performing on (y)
## Next we see strsplit needs a parameter of character strings (file names in x)
## Then the charachter we want to split the string on "/" then take the 11th index of the split string
## we set this to be exactly this index only with [[11]]
## next the 11th element will be subject to "unlist" and stored in Y
## Then we see unlist and string split combo again to get the name of the DBP or TF


  unique_tf <- unique(tf_name)

## ?unique
## here we see the unique function provide information to index each DBP as a unique 
## entry -- and still have the two or more replicate files. We use this in a for
## loop below so for each unique DBP we will perform a funciton to intersect the
## replicate files for peaks that are in both replicates.

  
  consensus_peaks <- list()
  # This for loop will iterate over all dna binding proteins.
  for(i in 1:length(unique_tf)) {
  # this is why we set up unique_tf above
    # load all the peak files corresponding to this dna binding proteins.
    tf <- unique_tf[i]
    tf_index <- grep(tf, tf_name)
    tf_files <- fl[tf_index]
    # we ultimately are setting up tf_files for the next for loop below. This
    # will give us a 
    
    peak_list <- c()
    for(j in 1:length(tf_files)) {
## ? read_peaks is a cool function in genomicRanges package. It will make a list 
## of ranges (coordinates) for the peaks. This will be used to find overlapping ranges.
## in this for loop we will filter out non-cannonical chromosome names
      
      peak_list <- c(peak_list, read_peaks(tf_files[j]))
    }
## Setting up peak_list and printing 'c()' the information of read_peaks for a unique
## DBP that we set up above. This will result in read_peaks reading in the peaks from 
## the replicate files in tf_files will both be read in.
    canonical_chr <- c(paste0("chr", 1:22), "chrM", "chrX", "chrY")
    # we are using paste0 to make a list of chr1 - chr22 and chrM etc
    # these are the only chromosomes we want so setting this up for below
    
    for(i in 1:length(peak_list)) {
      peak_list[[i]] <-peak_list[[i]][which(seqnames(peak_list[[i]]) %in% canonical_chr)]
    }
  
## This for loop is going to look throuhg the peak_list and retreive only the
## seqnames (?seqnames) that are %in% (handy r function!) our cannonical chr list.
   
     final_peakset <- intersect_peaks(peak_list = peak_list)
## intersect peaks is a function we made in the util folder intersect_functions.R
## It basically uses the genomicRanges package findOverlaps that does the bulk 
## of the intersecting peaks between files in 'peak_files'
## the only parameter this function needs is the peak list object (they are named the same)
## Here is the intersect_peaks function below

#    intersect_peaks <- function(peak_list) {
#     combined_peaks <- peak_list[[1]]
#     for(i in 2:length(peak_list)) {
#     suppressWarnings(pl_ov <- findOverlaps(combined_peaks, peak_list[[i]]))
#   pl1 <- combined_peaks[unique(pl_ov@from)]
#   pl2 <- peak_list[[i]][unique(pl_ov@to)]
#   suppressWarnings(combined_peaks <- GenomicRanges::reduce(union(pl1, pl2)))
# }
#  return(combined_peaks)
#}
     
## of note the function reduce, that is a function that will merge two overlaping
## ranges. We take teh union of peak in list 1 and 2 (pl1, pl2). This means if they
## overlap it will take the furtherst ends of the ranges. If this was intersect
## it would produce the ranges only where the peaks overlap (much smaller region).
     
     
## now we return to the for loop with an 'if' statement that will only operate
## if the condition of the if statement are true. Here saying the final peak list
## needs to be greater than 0 -- otherwise there were no peaks.
## if greater than 0 peaks are found it will name each peak and put it into an
## object final_peakset and make a new column 'name' that consists of 
## the DBP (or TF) name with an underscore followed by the 1 through all the peaks
## that are in the final_peakset of overlapping peaks.
    if(length(final_peakset) > 0) {
      final_peakset$name <- paste0(tf, "_", 1:length(final_peakset))
    }
    
    consensus_peaks <- c(consensus_peaks, list(final_peakset))
    names(consensus_peaks)[length(consensus_peaks)] <- tf
    
## Now we are just tidying and finalizing the consensus_peaks. First concatinating
## consensus_peaks with all the peaks in final_peakset. The list function is 
## listing all the peaks in final_peakset and printing them to consensus_peaks.
## lastly using names to name each peak by the DBP (or TF) using <- to input the
## DBP name.
    
  }
  return(consensus_peaks)
}














# TODO: refactor
# TODO do we need this?
read_peaks <- function(broad_peak_file, filter_to_canonical_chr = FALSE) {
  # A broad peak file is just a tab separated file 
  dat <- read.table(broad_peak_file, sep = "\t")
  if(filter_to_canonical_chr == TRUE) {
    dat <- dat[dat$V1 %in% c(paste0("chr", 1:22), "chrM", "chrX", "chrY"),]
  }
  gr <- GRanges(seqnames = dat$V1,
                ranges = IRanges(start=dat$V2,end=dat$V3))
  return(gr)
}
# This is the function that will be doing the core of the work here. 
# When two peaks intercept, we will take their outer boundaries to be the new
# peak -- using the reduce function.
intersect_peaks <- function(peak_list) {
  combined_peaks <- peak_list[[1]]
  for(i in 2:length(peak_list)) {
    suppressWarnings(pl_ov <- findOverlaps(combined_peaks, peak_list[[i]]))
    pl1 <- combined_peaks[unique(pl_ov@from)]
    pl2 <- peak_list[[i]][unique(pl_ov@to)]
    suppressWarnings(combined_peaks <- GenomicRanges::reduce(union(pl1, pl2)))
  }
  return(combined_peaks)
}
```


