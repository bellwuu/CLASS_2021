---
title: "Creating Consensus Peaks / functions in R"
author: "JR"
date: "11/29/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```



First we are going to go over a "function" in R. This is a really nice feature of 
defining a function for R that you may run frequently. For example we have over 
1,000 peak files we have to import into R using the function below. 

We need a few minimum aspects in defining a function:
-note we use #' markdown for a function.

@description: describes the function
@param is a paramater that the function needs. 

Essentially R has many built in functions such as mutate that needs parameters etc.


Lets take a look.
```{r}

#' import peak .bed files as a list
#' 
#' @description 
#' this function will take consensus peak files and name them by the DNA binding protein and return a list
#' 
#' @param consensus_file_path the path to consensus peak files

```

Hopefully it is pretty self-explanatory that the function will only need one 
parameter -- the file path to the peak files generated by nextflow (.broadPeak)


This is the file path for the function parameter:

/Shares/rinn_class/data/CLASS_2021/CLASS_2021/data/test_work/all_peak_files

So now we will see the function get set up to work. The goal is to read in all
the files using this function. 

We will start by naming the function "import_peaks" 
We next call the function and give the parameter -- this is fead into "consensus peaks"

Now we are going to make some objects:

*peak_files: this is just going to be a list of the peak file names
this used the R function "list.files" -- take a look:
?list.files

*file_names: here we use the Tidyverse R function string extract (str_extract)
?str_extract (need tidyverse library loaded)
The arguments are:

string: the input vector of coerciable data (e.g. character string) -- peak_files
pattern: the pattern to look for across the input vector. this is using regular
expression (regex). You don't need to know this much regex, but if you are ever 
curious you can use the online regex calculator :)

https://regexr.com/

if you paste in the two regex commands below it will tell you what they are looking for.

*tf_name: here we are going to have the funciton grab the name of the DBP or TF 
that is associated with the file being read in peak_files. 

Overall, we are grabbing all the file names, using regex to parse the complex file
name into a simple file name attached to the DBP.


```{r}
import_peaks <- function(consensus_file_path = "/Shares/rinn_class/data/CLASS_2021/CLASS_2021/data/test_work/all_peak_files") {
  peak_files <- list.files(consensus_file_path, full.names = T)
  file_names <- str_extract(peak_files, "[\\w-]+\\.bed")
  tf_name <- str_extract(file_names, "^[^_]+(?=_)")
  
## Now we are going to use the data structures above in a forloop. 

  peak_list <- c()
## We will make an empyt object called peak_lists using <- () 
  for(i in 1:length(peak_files)) {
## next we set up the for loop to populate peak_list, for i through (:) the legnth of (peak_files).
## This starts the for loop to run through each of the file names in peak_files
    peaks <- rtracklayer::import(peak_files[i])
## here we are going to import the "ranges" or locations of the peaks in each file
## this is using the GRanges R package with 
## the 'rtracklayer::import' is using '::' to say use the package rtracklayer import
## function and not the base R import funciton etc. Many packages use functions
## with the same names, so you want to call them directly with ::
## We will discuss Iranges and Granges soon, but for now the importance of this
## is to index the chromosome and coordinates of each peak for each DBP. rtracklayer
## knows how to do this.
    
    peak_list <- c(peak_list, peaks)
## Here we are simply concatinating what is in 'peak_list' with what was put into 
## 'peaks' above
    
    names(peak_list)[length(peak_list)] <- tf_name[i]
    
## ?names
## ?length
## here we see the base R funciton "names" it does exactly what it sounds like
## it either sets or get's the names in an onject (e.g. peak_list)
## so we are running names on the "peak_list" object and then indexing into "peak_list"
## using [ ] that we have seen before.
## whats new here is running a function (lenght) in the indexing!
## length will set the length of names to be the length of peak list -- remember
## 'peak_list' is getting populated each time in the for loop so we need to have
## names add until there are no more files coming into 'peak_list' from the for loop.

## finally we made 'tf_name' above which is connected to each file in the loop (i:legnth peak_files)
## we are now going to plug this into the name of the file currently in 'peak_list'
    
  }
  return(peak_list)
}

## simply closing out the function and has the funciton return the peak_list object
## a function will always want a return command at the end.
```






Now we have our peak_files in an object that knows where the peaks are on
each chromosome. Next we want to merge the peaks called in each replicate to 
"consensus peaks" that are consistent in all replicates. Thus we will compress
our peak_list into a final set of peaks that are reliable across biological replicates.


We start with a similar funciton set up:


```{r}
#' intersect replicates into a "consensus peak list" 
#' 
#' @description 
#' this function will take the intersect and union of peak widths across replicates for a given DNA binding protein. the function that will take a list of granges objects and return 
# one granges object with merged peaks that are in all replicates
#' 
#' @param 
#'  the path to consensus peak files
#' # We're going to iterate over all the files to make it work. 

```


Now we are going to put the function to work and give it the same file path
paramater as above. 
```{r}
create_consensus_peaks <- function(broadpeakfilepath = "/Shares/rinn_class/data/CLASS_2021/CLASS_2021/data/test_work/all_peak_files") {
  
  
  fl <- list.files(broadpeakfilepath, 
                   full.names=TRUE)
  fl <- fl[grep("peaks.broadPeak", fl)]
  
  tf_name <- sapply(fl, function(x){
    y <-  unlist(strsplit(x, "/"))[[11]]
    unlist(strsplit(y, "_"))[[1]]
  })
  
  unique_tf <- unique(tf_name)
  
  consensus_peaks <- list()
  # This for loop will iterate over all dna binding proteins.
  for(i in 1:length(unique_tf)) {
    
    # load all the peak files corresponding to this dna binding proteins.
    tf <- unique_tf[i]
    tf_index <- grep(tf, tf_name)
    tf_files <- fl[tf_index]
    
    peak_list <- c()
    for(j in 1:length(tf_files)) {
      # See the read peaks function to know what subfunctions are called.
      peak_list <- c(peak_list, read_peaks(tf_files[j]))
    }
    
    canonical_chr <- c(paste0("chr", 1:22), "chrM", "chrX", "chrY")
    for(i in 1:length(peak_list)) {
      peak_list[[i]] <-peak_list[[i]][which(seqnames(peak_list[[i]]) %in% canonical_chr)]
    }
    
    final_peakset <- intersect_peaks(peak_list = peak_list)
    if(length(final_peakset) > 0) {
      final_peakset$name <- paste0(tf, "_", 1:length(final_peakset))
    }
    
    consensus_peaks <- c(consensus_peaks, list(final_peakset))
    names(consensus_peaks)[length(consensus_peaks)] <- tf
  }
  return(consensus_peaks)
}

# TODO: refactor
read_peaks <- function(broad_peak_file, filter_to_canonical_chr = FALSE) {
  # A broad peak file is just a tab separated file 
  dat <- read.table(broad_peak_file, sep = "\t")
  if(filter_to_canonical_chr == TRUE) {
    dat <- dat[dat$V1 %in% c(paste0("chr", 1:22), "chrM", "chrX", "chrY"),]
  }
  gr <- GRanges(seqnames = dat$V1,
                ranges = IRanges(start=dat$V2,end=dat$V3))
  return(gr)
}
# This is the function that will be doing the core of the work here. 
# When two peaks intercept, we will take their outer boundaries to be the new
# peak -- using the reduce function.
intersect_peaks <- function(peak_list) {
  combined_peaks <- peak_list[[1]]
  for(i in 2:length(peak_list)) {
    suppressWarnings(pl_ov <- findOverlaps(combined_peaks, peak_list[[i]]))
    pl1 <- combined_peaks[unique(pl_ov@from)]
    pl2 <- peak_list[[i]][unique(pl_ov@to)]
    suppressWarnings(combined_peaks <- GenomicRanges::reduce(union(pl1, pl2)))
  }
  return(combined_peaks)
}
```


