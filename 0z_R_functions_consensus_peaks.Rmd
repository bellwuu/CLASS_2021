---
title: "Creating Consensus Peaks / functions in R"
author: "JR"
date: "11/29/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```



First we are going to go over a "function" in R. This is a really nice feature of 
defining a function for R that you may run frequently. For example we have over 
1,000 peak files we have to import into R using the function below. 

We need a few minimum aspects in defining a function:
-note we use #' markdown for a function.

@description: describes the function
@param is a paramater that the function needs. 

Essentially R has many built in functions such as mutate that needs parameters etc.


Lets take a look.
```{r}

#' import peak .bed files as a list
#' 
#' @description 
#' this function will take consensus peak files and name them by the DNA binding protein and return a list
#' 
#' @param consensus_file_path the path to consensus peak files

```

Hopefully it is pretty self-explanatory that the function will only need one 
parameter -- the file path to the peak files generated by nextflow (.broadPeak)


This is the file path for the function parameter:

/Shares/rinn_class/data/CLASS_2021/CLASS_2021/data/test_work/all_peak_files

So now we will see the function get set up to work. The goal is to read in all
the files using this function. 

We will start by naming the function "import_peaks" 
We next call the function and give the parameter -- this is fead into "consensus peaks"

Now we are going to make some objects:

*peak_files: this is just going to be a list of the peak file names
this used the R function "list.files" -- take a look:
?list.files

*file_names: here we use the Tidyverse R function string extract (str_extract)
?str_extract (need tidyverse library loaded)
The arguments are:

string: the input vector of coerciable data (e.g. character string) -- peak_files
pattern: the pattern to look for across the input vector. this is using regular
expression (regex). You don't need to know this much regex, but if you are ever 
curious you can use the online regex calculator :)

https://regexr.com/

if you paste in the two regex commands below it will tell you what they are looking for.

*tf_name: here we are going to have the funciton grab the name of the DBP or TF 
that is associated with the file being read in peak_files. 

Overall, we are grabbing all the file names, using regex to parse the complex file
name into a simple file name attached to the DBP.


```{r}
import_peaks <- function(consensus_file_path = "/Shares/rinn_class/data/CLASS_2021/CLASS_2021/data/test_work/all_peak_files") {
  peak_files <- list.files(consensus_file_path, full.names = T)
  file_names <- str_extract(peak_files, "[\\w-]+\\.bed")
  tf_name <- str_extract(file_names, "^[^_]+(?=_)")
  
## Now we are going to use the data structures above in a forloop. 

  peak_list <- c()
## We will make an empyt object called peak_lists using <- () 
  for(i in 1:length(peak_files)) {
## next we set up the for loop to populate peak_list, for i through (:) the legnth of (peak_files).
## This starts the for loop to run through each of the file names in peak_files
    peaks <- rtracklayer::import(peak_files[i])
## here we are going to import the "ranges" or locations of the peaks in each file
## this is using the GRanges R package with 
## the 'rtracklayer::import' is using '::' to say use the package rtracklayer import
## function and not the base R import funciton etc. Many packages use functions
## with the same names, so you want to call them directly with ::
## We will discuss Iranges and Granges soon, but for now the importance of this
## is to index the chromosome and coordinates of each peak for each DBP. rtracklayer
## knows how to do this.
    
    peak_list <- c(peak_list, peaks)
## Here we are simply concatinating what is in 'peak_list' with what was put into 
## 'peaks' above
    
    names(peak_list)[length(peak_list)] <- tf_name[i]
    
## ?names
## ?length
## here we see the base R funciton "names" it does exactly what it sounds like
## it either sets or get's the names in an onject (e.g. peak_list)
## so we are running names on the "peak_list" object and then indexing into "peak_list"
## using [ ] that we have seen before.
## whats new here is running a function in the indexing!

  }
  return(peak_list)
}

```

