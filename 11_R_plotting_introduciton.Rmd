---
title: "10_Intro_plotting_R"
author: "JR"
date: "12/7/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(ggpubr)
library(tidyverse)
source("util/plotting_functions.R")
source("util/_setup.R")

```

One of the best parts of R is the plotting abilities. You are, by analogy designing your own figures with code. You can run many stastical analyses and plot the outputs in the code to make a figure.

Here we will focus on GGPLOT(GGPLOT2). The GG says it all:

"Grammar of Graphics" -- it truly is a very pure and flexible way of plotting data for figures!


Although this is a package it is the best for vast majority of figure making.
There are base R functions that can read excel files etc, but we hopefully will be so clean and tidy we won't be loading excel files into R :) 

There are 8 possible layers of information -- each building on the data layer that you are importing. This looks really confusing but we will slowly build up from the basics (mapping, stats, geom)

You can also think of ggplot2 as an API. There are alternatives such as Vega-lite that are also based in graphical grammar.


Plotting layers of R:

1) Data -- data being plotted from object indexes etc.

2) MAPPING -- mapping data (aes)

3) Statistics -- statical analyses on mapped data

4) scales -- how big small you want things

5) GEOMETRIES -- what type of plots you are making (geom)

6) Facets -- making multiple representations of plots

7) Coordinates -- specifing placement of image aspects

8) THEME -- a set version of colors, background. Mostly so you don't have to add many of the layers above everytime!

The nice thing, to me, is that these layers don't have to come in order. But many of the later layers require data already to be mapped in aes().

Ok let's walk through some simple examples to more difficult figures using these layers!

Layer 1 : DATA (data types matter so good to label object accrodingly)

```{r}
# before we get started let's import that data we are going to     # plot. We will use the peak occurent matrix from our previous
# general analysis of the data previously (10_our_data_ranges).

num_peaks_df <- read_csv2('chipseq/results/num_peaks_df.csv')

# Cool, take a look and we can start plotting these columns !
```




```{r}
# let's make this simple plot first

ggplot(num_peaks_df, aes(x = num_peaks_df$num_peaks,
                     y = num_peaks_df$total_peak_length)) +
  geom_point()

# here we are just looking at a x, y point plot (geom_point).
# note there are not quotes on x, and y objects as they are being evaluated as "objects in ggplot"
# note the +, we will see this everytime we are adding a new layer. # Yet within each layer it's standard comma 
# seperated etc.
# '+' adds layers together

## Lets compare the above with this:

ggplot(num_peaks_df) +
  geom_point(aes(x = num_peaks_df$num_peaks, 
                 y = num_peaks_df$total_peak_length))
             
# Here we simply deliniated the "data" layer and then used the 
# geom_point to set the aes values. This is just to show you can 
# move things around as long as you are following logic.

             
# There is lots more we could modify here but let's change the shape of the points to show off R plotting.

ggplot(num_peaks_df) +
  geom_point(aes(x = num_peaks_df$num_peaks, 
                 y = num_peaks_df$total_peak_length, shape = 'square' ))

# Now the points are plotted as squares.
  

? geom_point 
# scroll to the Aestheitcs section for all options
# cool let's make the squares more transparent for example

ggplot(num_peaks_df) +
  geom_point(aes(x = num_peaks_df$num_peaks, 
                 y = num_peaks_df$total_peak_length, 
                 shape = 'square',
                 alpha = '0.3'))
# we shouldn't really use alpha for discrete values
# but we will see later that this can be useful to see
# two plots on top of each other. 

# so much can be done in the Aesethics mapping layer!

# We can also add some color features in the mapping layer of graphical grammar let's take a look

ggplot(num_peaks_df) +
  geom_point(aes(x = num_peaks_df$num_peaks, 
                 y = num_peaks_df$total_peak_length, 
                 shape = 'square',
                 alpha = '0.3',
                 color = num_peaks_df$num_peaks < 1e3))

# so we did a bit extra by adding a "function of less-than 1,000 peaks". 
# Thus R will know to add two colors to data with less than 1,000 peaks 
# and another color for those over 1,000 peaks.
# Finally note ggplot gives us a free title and legend!

#TODO add color -- currently doesn't work!
ggplot(num_peaks_df) +
  geom_point(aes(x = num_peaks_df$num_peaks, 
                 y = num_peaks_df$total_peak_length, 
                 shape = 'square',
                 color = 'green',
                 alpha = '0.3')) 
            
# This is not MAPPING colours, it is SETTING colours
# It's subtle but why R is so powerful to MAP data !

```


# Histogram. This is great when you are inloadterested how often one variable occurs. So you would only use "x"
# or one data value in this case.

```{r}

ggplot(num_peaks_df) +
  geom_histogram(aes(x = num_peaks_df$num_peaks))

# Interesting it told us we should use more bins we can set this
# in the aes layer.

#TODO add more bins -- obvious way didn't work

# Pretty simple! But there could be a lot more -- so it's worth looking in manual !
# genom_histogram and look for "Asethics" section in manual will be able to tadd more.
# Let's chage the color of the bars in histogram by number of peaks.

ggplot(num_peaks_df) +
  geom_histogram(aes(x = num_peaks_df$num_peaks, fill =    num_peaks_df$num_peaks > 1000))

# cool so we can color the two different histograms by 
# those DBPs with more than 1,000 or less than 1,000
# However it's too dense as is. let's change how the bars are # POSITIONED

# Todo dodge isn't working
ggplot(num_peaks_df) +
  geom_histogram(aes(x = num_peaks_df$num_peaks, fill = num_peaks_df$num_peaks > 1000, positon = "dodge" ))
  
  #TODO couldn't get geom vline to work :)

# This is just to show we can alot more features in the mapping layer to make the figures
# more readable and clear as possible.




# Let's try one more additon where fill is based on a different value in the table!
# Let's compare the distribution of peak numbers that are above 1MB in total coverage
# We can index into that in the df we are plotting

ggplot(num_peaks_df) +
  geom_histogram(aes(x = num_peaks_df$num_peaks, fill = num_peaks_df$total_peak_length > 1e6))
#TODO need to add dodge or non overlap

# DENISTY Plots are also very useful to see where the denisty of data arises.

ggplot(num_peaks_df) +
  geom_density(aes(x = num_peaks_df$num_peaks))

# Nice so sometimes we want a histogram and denisity plots for all values of some x

# We can even add layers of plots. For example a 2 dimensional denisty plot of our x, y point plot above.
# Let's check it out


#TODO can't figure out why it won't pipe forwrad to geom_denisty_2d
# should be able to just + and geom_denisty_2d() and should fill?
ggplot(num_peaks_df) +
  geom_point(aes(x = num_peaks_df$num_peaks, 
                 y = num_peaks_df$total_peak_length)) +
  geom_density_2d(aes(x = num_peaks_df$num_peaks, 
                 y = num_peaks_df$total_peak_length)) 
  

```

You can do a lot in the geometry layer and add features with + and then new geom call. Let's look at 
# this below


```{r}
# Now let's see how to add other features to the plots by adding an additional geom layer as we did above
# Lets explore 'geom_abline' geometry to add a line 
?geom_abline

ggplot(num_peaks_df) +
  geom_point(aes(x = num_peaks_df$num_peaks, 
                 y = num_peaks_df$total_peak_length)) +
  geom_abline(slope = 1000, intercept = 0)

```

Let's take a quick look at bar plots
```{r}
# Here we will look at more aspects of graphical grammar with bar plots
# TODO  see if we can select certain DBPs names(dbp = *Z)
ggplot(num_peaks_df) +
  geom_bar(
    aes(
      x = num_peaks_df$dbp,
      y = after_stat(num_peaks_df$total_peak_length  / 1e6)
    )
  )
# Notice here we called after_stat function to let R know we are manipulating the data
# that is going to be plotted on Y-axis. The peak width is so big we want to shrink it down to # intervals of 1 million.

# We also add a fill command in the mapping layer.
```

Now we have gone through these layers:

1) Data -- data being plotted from object indexes etc.

2) MAPPING -- mapping data (aes)

3) Statistics -- statical analyses on mapped data

5) Geom

# Now let's look at the scales layer

4) scales -- how big small you want things
# Scales is important for outputting specific factors as colors that are "scaled"
# alos other outputs need to be scaled such as scale values to the "mean" etc.
?scale

```{r}
# Let's use our num_peaks versus peak width to see this
# Todo color by lncRNA and mRNA 
ggplot(num_peaks_df) +
  geom_point(
    aes(
      x = num_peaks_df$dbp,
      y = num_peaks_df$total_peak_length / 1e6))
  scale_colour_brewer(type = 'qual')
# qual is a type scale_colour_brewer that has many color palattes
# We can also set Pallete directly:

  #TODO can't find direct color palette 

  ggplot(num_peaks_df) +
  geom_point(
    aes(
      x = num_peaks_df$dbp,
      y = num_peaks_df$total_peak_length / 1e6))
  scale_colour_brewer(palette =  'set1')
  

#Let's look at sclaing the axes

ggplot(num_peaks_df) +
  geom_point(
    aes(
      x = num_peaks_df$num_peaks,
      y = num_peaks_df$total_peak_length / 1e6)) +
  scale_x_continuous(breaks = c(1e3, 1e4, 1e5, 1e6)) +
  scale_y_continuous(trans = 'log10')

# notice 1e6 is not plotted since there are no total peak widths 
# that cover that much space.

# here we are saying where the points on X axis we want and to "TRANSFORM" (trans)
# the Yaxis to log10 scale. 

# The most common use of scale is to set the limits of a scale

#TODO not sure why this doesn't work!
ggplot(num_peaks_df) +
  geom_point(
    aes(
      x = num_peaks_df$num_peaks,
      y = num_peaks_df$total_peak_length / 1e6))
  scale_x_continuous(limits = c(0, 1e4)) +
  scale_y_continuous(limits = c(0,100))

# This is really helpful when you want to zoom in on certain       # aspects of the data.
```

Now let's look at 6) FACETS
This will allow us to make multiple plots in the same plot frame or facet
One limitation is that it can only make the same plots from different data


```{r}
#TODO Debug

ggplot(num_peaks_df) +
  geom_point(aes(x = num_peaks_df$num_peaks, y = num_peaks_df$total_peak_length )) +
  facet_wrap(num_peaks_df$num_peaks ~ num_peaks_df$peaks_overlapping_lncrna_promoters)
# facet the above to seperate  lncRNA and mRNA variable

# Nice we cna see these plotted seperately now but in the same pane.
# TODO another facet grid exercise
# We can also use 'facet_grid' that can pivot grids (turn x and y axis)
ggplot(num_peaks_df) +
  geom_point(aes(x = num_peaks_df$num_peaks, y = num_peaks_df$total_peak_length )) +
    facet_grid( num_peaks_df$num_peaks ~ num_peaks_df$total_peak_length)
```

7) Coordinates
How to represent X and Y coordinates in different coordinate systems.

```{r}

# TODO better coordinates example than polar :)?

ggplot(num_peaks_df) +
  geom_bar(aes(x = num_peaks_df$num_peaks)) +
  coord_polar()

# We can play around in here too to tell what is the "theta" or circular dimension

ggplot(num_peaks_df) +
  geom_bar(aes(x = num_peaks_df$num_peaks)) +
  coord_polar(theta = 'y')

ggplot(peaks) +
  geome_bar(aes(x = numpeaks)) +
  coord_polar(theta = 'y') +
  expand_limits (y = 1)

```

8) Theme
This is a great way to package all the features you want, colors,
backgrounds, grid lines etc. We tend to use paper white as a defualt theme.

We made a defualt theme that we can source at the begining of the
document call _setup.R. Once loaded a "paper white" theme will be available.

Let's look at example from 10_our_data_ranges

```{r}
g <- ggplot(num_peaks_df, aes(x = num_peaks_df$num_peaks))


g + geom_density(alpha = 0.2, color = "#424242", fill = "#424242") +
  theme_paperwhite() +
  xlab(expression("Number of peaks")) +
  ylab(expression("Density")) +
  ggtitle("Promoter binding events",
          subtitle = "mRNA and lncRNA genes") 
# we can see here how titles can easily be made with ggtile which
# is in the "theme" layer of things.

# Go take a look at _setup.R and see the features of paper white!
```


Now let's go back to the last figure exercise in 10_our_data_ranges. The big difference we are going
to see is a lot of code and functions run in the figure making. At first you can do all of these functions independently and create an object to plot later. Or sometimes you just want to get to something while plotting the figures :)

```{r}
num_peaks_dfl <- num_peaks_df %>%
  dplyr::select(-peaks_overlapping_promoters) %>%
  
  # the - sign here is saying take everything but the "peaks_overlapping_promoters"
  # below we are going to use a couple function 'select' and pivot longer. 
  # pivot longer can be a bit confusing but basically taking data with lots of 
  # rows and few columns and changing the rownames to colnames.
? pivot_longer

# We see we need two parameters: 
# names_to
# valuest_to
# we start with a third parameter cols from tidyverse to indicate the columns
# we want to keep. basically we are only keeping the lncRNA and mRNA promoter columns


#TODO why pivot longer instead of just plotting columns -- faster I am guessing?
  pivot_longer(cols = peaks_overlapping_lncrna_promoters:peaks_overlapping_mrna_promoters,
               names_to = "gene_type",
  # we are naming the new names for colnames to "gene_type" that is lncRNA or mRNA
               values_to = "peaks_overlapping_promoters") %>%
  # each row  (1 promoter) is going to become a column that we need to grab values for
  # here we are saying make the values name be 
  mutate(gene_type = gsub("peaks_overlapping_", "", gene_type))
ggplot(num_peaks_dfl, aes(x = num_peaks, y = peaks_overlapping_promoters, 
                         col = gene_type)) +
         geom_point() +
# ok this should look familiar now we are going to make a point plot  

         geom_abline(slope = 1, linetype="dashed") +
# here we are adding a abline geometry (needs slope) with handy linetype for stylizing.
  # previously we set intercept but that isn't required.
  
  geom_smooth(method = "lm", se = FALSE, formula = "y ~ x") +
# ?geom_smooth
# Cool we are smoothing out the data. parameters are 'method' , 'se', 'formula'
# method: we used lm for linear model (could be Loess or other models too)
# se: this is giving the "standard error" around the smoothed line(you never want average with our sd/se)
# formula: since we have an x, y value for every entry we can pass y ~ x. Always starts with 'y ~' but you # may need to evaluate x (but unlikely for our or your future purposes)
  
  stat_regline_equation() +
# this little function is R plotting is great. Just adding that line will give us R^2 and slope etc.
# We don't have to calculate these and then plot them -- R will just do it for us!
  
  scale_color_manual(values = c("#a8404c", "#424242"))+
# We are manually setting the colors of "mRNA" and for "lncRNA", R will defualt to others.
# Every color is associated with a number and you can google color numbers and find ones you like.
  
  xlab("Peaks per DBP") +
# Now we are labeling the axes. x= Peaks per DBP and Y below
  ylab("Peaks Overlapping Promoters") +
  ggtitle("Number of DBP Peaks and Promoter Overlaps")

# ggtitle will make the main title but there are other options in the manual. 
```

Class exercise, go back to one of the other figures from 10_our_data_ranges. Try and change some feature or add a regression line etc. Slack us what you get :)

