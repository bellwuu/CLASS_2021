---
title: "02_bashing_data"
author: "JR"
date: "10/19/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In 01_ we started explporing and downloading data. We ended up with a .tsv
file with all the data information we are interested in. Let's explore how we
can use bash to explore the table and learn some more unix commands.

Let's start with some of the very basics to get everybody on the same page:

cd - to change directories
ls - list the files
pwd - tells you the pathway you are currently at (very useful actually!)
```
cd ~/
ls
pwd
```
Wait could there be more? let's try:

```
ls -lah
```
Do you see new files and folders that start with .X ? These are invisible files
that are often very important. the -lah is called a flag that gives us more information. Let's see what they are 

```
man ls
```
-l for long
-a for all
-h human readable
basically I typically always use these flags

Now let's make a new file using touch

```
touch test.txt
ls
```
woah a new file shows up! What is in it? lets use Nano

```
nano test.txt
# type whatever
# ctrl x to get out and enter
```

Now let's take a look at the file with cat

```
cat test.txt
```
Cat will print all items in a file and sometimes they are very long. So there are other unix commands to get the head and tail of a file while specificying how many lines you want:

```
head -10 test.txt
tail -10 test.txt
```

Let's make another file and combine two files to highlight other functinality of the cat command

```
tocuh test2.txt
nano test2.txt
# type whatever
cat test.txt test2.txt > test3.txt
cat test3.txt
```

now let's make a folder to put all these files in use mkdir

```
mkdir practice
ls -lah
```

let's move the files in there 

```
mv test2.txt /practice
mv test3.txt /practice
mv test.txt / practice
ls
```

Nice and tidy. However that could be quite laborious if you wanted to move a bunch of files. So we can use WILDCARDS


http://www.linfo.org/wildcard.html

```
mv *.txt /practice
ls
```
This will move any file that ends in .txt the star means anything counts :)
There are many useful wild cards such as ? , [] etc here:

__________________________________
Imagine how much time one uses typing long file paths in the terminal. For example, in this class we will be using:

/Shares/rinn_class/data/CLASS_2021

That is no fun to type everytime and then go to the directory of interest. 

Good news there is a solution (used by nextflow and just how useful later) its called a sym-link and you have probably used them beofre. 

Let's make a sym-link to the class folder in your home directory 

```
cd ~/
ln -s /Shares/rinn_class/data/CLASS_2021 CLASS
ls
```

Now you see a sim-link called CLASS. You just cd CLASS and voila you are in class :)

Another handy short cut is to see how big a folder is. Often you are downloading to
or working on a folder and need to see if it became bigger or smaller. This is best
done wtih disk usage (du)

```
cd ~/
du -sh ~/
```

The -sh flag is for "s"ummary and "h"uman readable


|||||||||||||||||||||||||||||||||
The pipe
|||||||||||||||||||||||||||||||||


The pipe and xargs are two of the most elegant aspects of BASH. Let's try something
simple, so simple it may end up being used quite often :)

Many times a folder you are indexing may have hundreds or thousands of files.
There is no way we want to count them manually. So we can use the pipe to list (ls) 
the files in a directory and pipe it to word count (wc) to count the number of files.

Let's see:

```
cd ~/
ls | wc -l
```
Here the list output becomes the standard input to the word count owing to the pipe.
Or the pipe passed along the standard output of ls to standard input of wc. The 
-l flag is for the line count. 


Let's dig deeper into the pipe with something fun -- download a youtube video
from your terminal:

youtube-dl $1 -q -o - | ffmpeg -i - $2

downloads a video from the given youtube url passed by $1 and outputs it as the file given by $2. Note how the file is quietly -q output to STDOUT -o -, piped to ffmpeg and used as input there by -i -.








[*~*]$ find . -type f -name '*.jpg' -exec mv -i {} ../compiled/ \;


[*~*]$ find . -type f -name '*.mov' -exec mv -i {} ../compiled_movies/ \;


TSV fie

Grep 

AWK





