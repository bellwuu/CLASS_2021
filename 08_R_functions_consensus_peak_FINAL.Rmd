---
title: "Creating Consensus Peaks / functions in R"
author: "JR"
date: "11/29/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(GenomicRanges)
source("util/intersect_functions.R")
```



First we are going to go over a "function" in R. This is a really nice feature of 
defining a function for R that you may run frequently. For example we have over 
1,000 peak files we have to import into R using the function below. 

We need a few minimum aspects in defining a function:
-note we use #' markdown for a function.

@description: describes the function
@param is a paramater that the function needs. 

Essentially R has many built in functions such as mutate that needs parameters etc.


Lets take a look at the documentation of a test function


```{r}

#' import peak .bed files as a list
#' 
#' @description 
#' this function will take consensus peak files and name them by the DNA binding protein and return a list
#' 
#' @param consensus_file_path the path to consensus peak files

```



How and why would we write a function in R?

R already has a lot of built=in functions, but you can also make your own.
If you're finding yourself doing the same set of tasks over and over , this
can be wrapped into function. We saw an example of this in bash with the what-time-is-it.sh
script.

Now, let's see what it looks like in R. We know what a function is from math -- it takes
inputs and maps it to outputs, let's take a look at a classic polynomial function in R.

```{r}
# This function has two parameters, and we have to let R know
# that we want to be able to change the values of x and y.
# f(x) = x * y
# We also have to decide on a name for the function
fun <- function(x, y) { }
# Inside the curly braces is where we'll put the operations that the
# function will carry out.
# Then finally we will have the function return a value
fun <- function(x, y) {
  ans <- x * y
  return(ans)
}

fun(2,4)
```

When creating a function, you can also add documentation about what that function 
does and the data types and expectationn for the the parameters it takes.

```{r}
#' A function to multiply two numbers
#'
#' 
#' @description 
#' This function will multiply the input values of X and Y
#' 
#' @param x one number you'd like to multiply
#' @param y the other number you'd like to multiply
fun <- function(x, y) {
  ans <- x * y
  return(ans)
}
```


Note that if you were creating an R package (All those comp bio libraries we use
were created by grad students like yourself!), this formatting above the function
would compile into the nice documentation that you see in the help viewer pane.

For the purposes of this class project's organization, we'll put most of the functions
that we use in multiple analysis RMarkdown files, into the `../util` directory. 

Now let's look at the functions involved in making consensus peaks.
```{r}

#' Read peaks
#'
#' @description 
#' this function will take consensus peak files and name them by the DNA binding protein and return a list
#' 
#' @param consensus_file_path the path to consensus peak files
read_peaks <- function(consensus_file_path) { 
  # ...
  # You'll see below what goes in here.
  return(peak_list)
}

```

Hopefully it is pretty self-explanatory that the function will only need one 
parameter -- the file path to the peak files generated by nextflow (.broadPeak)

This is the file path for the function parameter:

/Shares/rinn_class/data/CLASS_2021/CLASS_2021/data/test_work/all_peak_files

So now we will see the function get set up to work. The goal is to read in all
the peaks contained in each file and change them to Granges objects. This means
it will know the coordinates of each peak in the genome for each DBP peak file.

We will start by naming the function "import_peaks" 
We next call the function and give the parameter (filepath) -- this is fed into "consensus peaks"

Now we are going to make some objects:

*peak_files: this is just going to be a list of the peak file names
this used the R function "list.files" -- take a look:
?list.files

*file_names: here we use the Tidyverse R function string extract (str_extract)
?str_extract (need tidyverse library loaded)
The arguments are:

string: the input vector of coerciable data (e.g. character string) -- peak_files
pattern: the pattern to look for across the input vector. this is using regular
expression (regex). You don't need to know this much regex, but if you are ever 
curious you can use the online regex calculator :)

https://regexr.com/

if you paste in the two regex commands below it will tell you what they are looking for.

*tf_name: here we are going to have the funciton grab the name of the DBP or TF 
that is associated with the file being read in peak_files. 

Overall, we are grabbing all the file names, using regex to parse the complex file
name into a simple file name attached to the DBP.



```{r}
read_peaks <- function(broad_peak_file, filter_to_canonical_chr = TRUE) {
  # A broad peak file is just a tab separated file 
  dat <- read.table(broad_peak_file, sep = "\t")
  if (filter_to_canonical_chr == TRUE) {
    dat <- dat[dat$V1 %in% c(paste0("chr", 1:22), "chrM", "chrX", "chrY"),]
  }
  gr <- GRanges(seqnames = dat$V1,
                ranges = IRanges(start = dat$V2,end = dat$V3))
  return(gr)
}

# import_peaks <- function(consensus_file_path = "/Shares/rinn_class/data/CLASS_2021/CLASS_2021/data/test_work/all_peak_files") {
#   peak_files <- list.files(consensus_file_path, full.names = T)
#   file_names <- str_extract(peak_files, "[\\w-]+\\.broadPeak")
#   tf_name <- str_extract(file_names, "^[^_]+(?=_)")
# ## ?list.files
# ## ?str_extract
# ## Now we are going to use the data structures above in a forloop. 
# ## the first regex is naming the file more succinctly. 
# ## The second regex is grabbing DBP name from the file name.
# 
#   peak_list <- c()
# ## We will make an empyt object called peak_lists using <- c() 
#   i <- 1
#   for(i in 1:length(peak_files)) {
# ## next we set up the for loop to populate peak_list, for i through (:) the legnth of (peak_files).
#     ## length is a base R function (? length)
# ## This starts the for loop to run through each of the file names in peak_files
#     peaks <- rtracklayer::import(peak_files[i])
# ## here we are going to import the "ranges" or locations of the peaks in each file
# ## this is using the GRanges R package with 
# ## the 'rtracklayer::import' is using '::' to say use the package rtracklayer import
# ## function and not the base R import funciton etc. Many packages use functions
# ## with the same names, so you want to call them directly with ::
# ## We will discuss Iranges and Granges soon, but for now the importance of this
# ## is to index the chromosome and coordinates of each peak for each DBP. rtracklayer
# ## knows the format of a broadPeak file and somehow knows exactly what to do -- we'll discuss later.
#     
#     peak_list <- c(peak_list, peaks)
# ## Here we are simply concatinating what is in 'peak_list' which starts at 0 and 
# ## after one round peak_list will contain the peaks of file i. peak_list will keep
# ## growing and peaks becomes new each time -- then the new peaks are appended to peak_list.
#     
#     names(peak_list)[i] <- tf_name[i]
#     
# ## ?names
# ## ?length
# ## here we see the base R funciton "names" it does exactly what it sounds like
# ## it either sets or get's the names in an onject (e.g. peak_list)
# ## so we are running names on the first item in "peak_list" [i] to get the DBP
# ## or TF name from file peak_list [i]. Now peak_list will be a NAMED list of Granges.
# ## Thus all the peak coordinates for each Chip will be stored and named by the DBP.
#     
#     
#   }
#   return(peak_list)
# }

## simply closing out the function and has the funciton return the peak_list object
## a function will always want a return command at the end.

```


Now we have our peak_files in an object that knows where the peaks are on
each chromosome. Next we want to merge the peaks called in each replicate to 
"consensus peaks" that are consistent in all replicates. Thus we will compress
our peak_list into a final set of peaks that are reliable across biological replicates.


We start with a similar funciton set up:


```{r}
#' intersect replicates into a "consensus peak list" 
#' 
#' @description 
#' this function will take the intersect and union of peak widths across replicates for a given DNA binding protein. the function that will take a list of granges objects and return 
# one granges object with merged peaks that are in all replicates
#' 
#' @param 
#'  the path to consensus peak files
#' # We're going to iterate over all the files to make it work. 

```


Now we are going to put the function to work and give it the same file path
paramater as above. Then the function will carry out all the commands between { }
This a bit redundant from what we just did above, bear with us we didn't have 
to repeat all this file loading, but hey it's never bad to see a new example. 
```{r}
create_consensus_peaks <- function(broadpeakfilepath = "/Shares/rinn_class/data/CLASS_2021/CLASS_2021/data/test_work/all_peak_files") {
  
  
  fl <- list.files(broadpeakfilepath, 
                   full.names = TRUE)
  fl <- fl[grep("broadPeak", fl)]

# fl: this is just going to be a list of the peak file names
# this used the R function "list.files" -- take a look:
# ?list.files

# *file_names: here we use the Tidyverse R function string extract (str_extract)
# ?str_extract (need tidyverse library loaded)
# The arguments are:
  
# string: the input vector of coerciable data (e.g. character string) -- peak_files
# pattern: the pattern to look for across the input vector. this is using regular
# expression (regex). You don't need to know this much regex, but if you are ever 
# curious you can use the online regex calculator :)
# 
# https://regexr.com/
# 
# if you paste in the two regex commands below it will tell you what they are looking for.
# 
# *tf_name: here we are going to have the funciton grab the name of the DBP or TF 
# that is associated with the file being read in peak_files. 
# 
# Overall, we are grabbing all the file names, using regex to parse the complex file
# name into a simple file name attached to the DBP.

## Here we are reading in files first again and putting them in the object "create_consensus_peaks"
## We are using grep to just grab broadPeak files. This is because the macs folder has many different
## versions of peak files. It is just useful to be sure it grabs the right file type.
## In our case the folder all_peak_files is only broadPeak files so a bit redundant....for safety.
  
  tf_name <- sapply(fl, function(x){
    file_name <- str_extract(x, "[\\w-]+\\.broadPeak")
    str_extract(file_name, "^[^_]+(?=_)")
  })
## So many new functions
## ?sapply
## ?Unlist
## ?strsplit

## The first command sapply needs a parameter of what to work on (fl or list of file names)
## then sapply wants to perform a funciton -- here we set the function to carry out the content in { }
## Here these commands are being executed in the function(x) that is anonymous or
## unnamed function. Here we see str_extract on x (which is the current file name)
## then using Regex we rename the files as we did above.

  unique_tf <- unique(tf_name)

## ?unique
## here we see the unique function provide information to index each DBP as a unique 
## entry.

  
  consensus_peaks <- list()
  # This for loop will iterate over all dna binding proteins.
  for(i in 1:length(unique_tf)) {
  # this is why we set up unique_tf above so the for loop will only run on one DBP
  # at a time, and merges the peaks of the replicate files associated with each DBP.
  # then the for loop will move onto the next unique_tf and merge those peak files.
    # load all the peak files corresponding to this dna binding protein.
    dbp <- unique_tf[i]
    tf_files <- fl[grep(dbp, fl)]
    # we ultimately are setting up tf_files for the next for loop below. This
    # will give us a na
    
    peak_list <- c()
    for(j in 1:length(tf_files)) {
## ? read_peaks is a cool function in genomicRanges package. It will make a list 
## of ranges (coordinates) for the peaks. This will be used to find overlapping ranges.
## in this for loop we will filter out non-cannonical chromosome names
      
      peak_list <- c(peak_list, read_peaks(tf_files[j]))
    }
## Setting up peak_list and printing 'c()' the information of read_peaks for a unique
## DBP that we set up above. This will result in read_peaks reading in the peaks from 
## the replicate files in tf_files will both be read in.
    canonical_chr <- c(paste0("chr", 1:22), "chrM", "chrX", "chrY")
    # we are using paste0 to make a list of chr1 - chr22 and chrM etc
    # these are the only chromosomes we want so setting this up for below
    
    for(i in 1:length(peak_list)) {
      peak_list[[i]] <-peak_list[[i]][which(seqnames(peak_list[[i]]) %in% canonical_chr)]
    }
  
## This for loop is going to look throuhg the peak_list and retreive only the
## seqnames (?seqnames) that are %in% (handy r function!) our cannonical chr list.
   
     final_peakset <- intersect_peaks(peak_list = peak_list)

     # Here we are going to run a function we made to intersect peaks!
     # note we sourced the function "intersect_peaks" from above
     # source("../util/intersect_functions.R")
     
## intersect peaks is a function we made in the util folder intersect_functions.R
## It basically uses the genomicRanges package findOverlaps that does the bulk 
## of the intersecting peaks between files in 'peak_files'
## the only parameter this function needs is the peak list object (they are named the same)
## Here is the intersect_peaks function below

#    intersect_peaks <- function(peak_list) {
#     combined_peaks <- peak_list[[1]]
#     for(i in 2:length(peak_list)) {
#     suppressWarnings(pl_ov <- findOverlaps(combined_peaks, peak_list[[i]]))
#   pl1 <- combined_peaks[unique(pl_ov@from)]
#   pl2 <- peak_list[[i]][unique(pl_ov@to)]
      # we will go over the indexes @from and @to in environment pane.
#   suppressWarnings(combined_peaks <- GenomicRanges::reduce(union(pl1, pl2)))
# }
#  return(combined_peaks)
#}
     
## of note the function reduce, that is a function that will merge two overlaping
## ranges. We take teh union of peak in list 1 and 2 (pl1, pl2). This means if they
## overlap it will take the furtherst ends of the ranges. 
     
     
## now we return to the for loop with an 'if' statement that will only operate
## if the condition of the if statement are true. Here saying the final peak list
## needs to be greater than 0 -- otherwise there were no peaks.
## if greater than 0 peaks are found it will name each peak and put it into an
## object final_peakset. Essentially we have another named (DBP) list of Granges (peak coordinates)
     
     
     
## IF the peak list isn't empty, then we assign a unique name to each peak. 
## the DBP (or TF) name with an underscore followed by the 1 through all the peaks
## that are in the final_peakset of overlapping peaks.
    if(length(final_peakset) > 0) {
      final_peakset$name <- paste0(tf, "_", 1:length(final_peakset))
    }
    
    consensus_peaks <- c(consensus_peaks, list(final_peakset))
    names(consensus_peaks)[length(consensus_peaks)] <- tf
    
## Now we are just tidying and finalizing the consensus_peaks. First concatinating
## consensus_peaks with all the peaks in final_peakset. The list function is 
## listing all the peaks in final_peakset and printing them to consensus_peaks.
## lastly using names to name each peak by the DBP (or TF) using <- to input the
## DBP name.
    
  }
  return(consensus_peaks)
}

# Write the consensus peaks to a file and take the name of the file
# from the name of the list element -- which   should be the DBP name.
for (i in 1:length(consensus_peaks)) {
  rtracklayer::export(consensus_peaks[[i]], 
                      paste0("results/consensus_peaks/", 
                             names(consensus_peaks)[i],".bed"))
}

```

