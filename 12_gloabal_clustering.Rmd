---
title: "12_Clustering"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggdendro)
library(GenomicRanges)
source("util/intersect_functions.R")
source("util/plotting_functions.R")
source("util/_setup.R")
```

The goal for today is to "cluster" the 438 DBPs to find which ones have similar binding profiles across the genome -- and those that are different. 

A lot of what we are going to do today was set up in 10_our_data_ranges and a good 
example of how you want to make output files for future analyses.

Let's start by refreshing our memory of what all went down in 10_our_data_ranges.

Briefly we did 2 really good things that we will need:

1) We made a list of (i) all promoters (ii) lncRNA promoters only (iii) mRNA promoters
2) We made a "tag_matrix" (.tsv) that is comprised of columns as every promoter in the genome. Rows are the DBP and filled 1 or 0 if that DBP binds to a given promoter. Or:

Promoter 1, 2, 3, ....
DBP      0, 0, 1,....

Thus, each row has ~60,000 1/0 for a given DBP. This is binary data (1/0) and not contious data. We need to consider that when clustering as these similarity measurements will be influenced by continious or binary data.

Here is what we did in 10_our_data_ranges:
```{r}
# We loaded Gencode annotaitons to get all the genome annotations. 

gencode_gr <- rtracklayer::import("/Shares/rinn_class/data/genomes/human/gencode/v32/gencode.v32.annotation.gtf")

# then we used "get_promoter_regions" in our intersect_functions.R to get the promoter # regions from Gencode.

# The function looks like this :

get_promoter_regions <- function(gencode_gr, biotype, upstream = 3e3, downstream = 3e3) {
  
  genes <- gencode_gr[gencode_gr$type == "gene"]
  genes <- genes[genes$gene_type %in% biotype]
  
  proms <- GenomicRanges::promoters(genes, upstream = upstream, downstream = downstream)
  
  return(proms)
  
}

# Go over this function and explain as class exeRcise.

```

Once we have all of our promoter regions we then seperated them into all, lncNRA and mRNA promoters. Note that all we really did is index into gencode_gr and then biotype:


```{r}

lncrna_mrna_promoters <- get_promoter_regions(gencode_gr, biotype = c("lncRNA", "protein_coding"))
rtracklayer::export(lncrna_mrna_promoters, "results/lncrna_mrna_promoters.gtf")

lncrna_promoters <- get_promoter_regions(gencode_gr, biotype = "lncRNA")
rtracklayer::export(lncrna_promoters, "results/lncrna_promoters.gtf")

mrna_promoters <- get_promoter_regions(gencode_gr, biotype = "protein_coding")
rtracklayer::export(mrna_promoters, "results/mrna_promoters.gtf")

# So we did the intersections and then wrote out a .GTF file that we will use today.


```

The best thing we did is use our "count_peaks_per_feature" function. Let's take a look at that to review. Note the paramaters that can be used (either tag or count) the tag matrix will be used for clustering and the count function made our "num_peaks_df" that we used in our plotting exceRcise (11_R_plotting_introduction)


```{r}
#' function to summarize the number of events in features on each individual promoter. 
#' 
#' @description 
#' Take a gencode gtf to subset the biotype of promoters we want as a set of GRanges
#' 
#' @param features
#' set of genomic features as a GRanges object
#'  
#' @param peak_list
#' #list of peaks of dna binding proteins that will be intersected
#' 
#' @param type
#' Return either a matrix of counts over features or a binary occurrence matrix

count_peaks_per_feature <- function(features, peak_list, type = "counts") {
  
  if(!(type %in% c("counts", "occurrence"))) {
    stop("Type must be either occurrence or counts.")
  }
  
  peak_count <- matrix(numeric(), ncol = length(features), nrow = 0)
  
  for(j in 1:length(peak_list)) {
    suppressWarnings(ov <- countOverlaps(features, peak_list[[j]]))
    peak_count <- rbind(peak_count, ov)
    rownames(peak_count)[nrow(peak_count)] <- names(peak_list)[j]
    colnames(peak_count) <- features$gene_id
  }
  
  peak_matrix <- peak_count
  
  if(type == "occurrence") {
    peak_occurrence <- matrix(as.numeric(peak_count > 0), 
                              nrow = dim(peak_count)[1],
                              ncol = dim(peak_count)[2])
    rownames(peak_occurrence) <- rownames(peak_count)
    colnames(peak_occurrence) <- colnames(peak_count)
    peak_matrix <- peak_occurrence
  }
  
  return(peak_matrix)
  
}

```


```{r}

# First we will establish the promoter peak occurence matrix (rows = promoters, cols # = dbp binding {0,1}). The reason for doing this is it has all the information in
# a matrix where the row is a dBP and columns are a promoter. Our current dataframe
# only knows the number of promoters overlapped, but not the names of the promoters.
# That could be handy and why we made a parameter of "count_peaks_per_feature" to be
# able to provide the counts (as we did above) or "occurence" the matrix.
promoter_peak_occurence <- count_peaks_per_feature(lncrna_mrna_promoters, filtered_consensus_peaks, 
                                               type = "occurrence")
# Output to promoter_peak_occurecne_matrix
write.table(promoter_peak_occurence, "results/lncrna_mrna_promoter_peak_occurence_matrix.tsv")




```

